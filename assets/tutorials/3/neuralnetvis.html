
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  
  

    <style>
      /* explanation for @namespace here: http://stackoverflow.com/questions/23034283/is-it-possible-to-use-htmls-queryselector-to-select-by-xlink-attribute-in-an */
      @namespace xlink "http://www.w3.org/1999/xlink";
      circle.node:hover {
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.2);
        transition: all 200ms ease-out;
      }
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<!--    <script type="text/javascript" src="http://code.interactjs.io/v1.2.6/interact.min.js"></script>-->
  
  
  
  <script type="text/javascript" async>
    if (!document.registerElement) {
        document.writeln(decodeURI('%3Cscript%20src=%22https://cdnjs.cloudflare.com/ajax/libs/webcomponentsjs/0.7.12/webcomponents.min.js%22%20type=%22text/javascript%22%3E%3C/script%3E'));
    }
  </script>

<script src="knob/index.js" type="text/javascript" async></script>
<link id="knobstyle" href="knob/style.css" type="text/css" rel="stylesheet">



<style type="text/css" shim-shadowdom>
/* Requires shim-shadowdom and webcomponentsjs in Firefox (due to lack of ::shadow support). https://github.com/Polymer/docs/issues/269 */
#transition x-knob::shadow .knob_gfx { transition: 125ms transform; }
</style>
  
</head>

<body>
  <?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet href="knob/style.css" type="text/css"?>
  <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
    <script> // sizing variables
      var width = 960;
      var height = 500;
      var nodeSize = 25;

      var inputcolor = "green";
      var outputcolor = "blue";
    </script>
    <script> // process nodes
      
      // works best if the layer indices start at 1
      data = [
        {"label": "input 1", "layer": 1, bias: 0},
        {"label": "hidden 1", "layer": 2, bias: 0},
        {"label": "hidden 2", "layer": 2, bias: 0},
        {"label": "output 1", "layer": 3, bias: 0}
      ];
      
      // refer to nodes by their labels. 
      // if a weight isn't specified for a connection, default will be 1
      weights = [
        {"startLabel": "input 1", "endLabel": "hidden 1", "weight": 5},
        {"startLabel": "hidden 1", "endLabel": "output 1", "weight": -3},
        {"startLabel": "input 1", "endLabel": "hidden 2", "weight": 2}
      ]
      
      // creates a dict containing the number of nodes in each layer
      // structure[layer] = # of nodes
      function getStructure(data) {
        var structure = {};
        for(var i = 0; i < data.length; i++) {
          var node = data[i];
          if(node.layer in structure) {
            structure[node.layer] += 1;
          }
          else {
            structure[node.layer] = 1;
          }
        }
        return structure;
      }
      
      // dict containing how many nodes in each layer
      // networkStructure[layer] = # of nodes
      var networkStructure = getStructure(data); 
      
      var inputlayer = Math.min.apply(null, Object.keys(networkStructure));
      var outputlayer = Math.max.apply(null, Object.keys(networkStructure));
      
      // creates nodes with labels, layers, and position
      function positionNodes(data, structure) {
        var nodes = []; // contains newly created nodes
        // sets width between layers
        var layerwidth = width / (Object.keys(structure).length + 1);
        // counts number of nodes drawn so far in each layer (inverse of structure)
        var nodeCount = {};
        for(var i = 0; i < data.length; i++) {
          if(data[i].layer in nodeCount) {
            nodeCount[data[i].layer] += 1;
          }
          else {
            nodeCount[data[i].layer] = 1;
          }
          var node = {"label": data[i].label,
                      "layer": data[i].layer,
                      "bias": data[i].bias};
          var x = layerwidth * node.layer;
          var y = nodeCount[node.layer] * height / (structure[node.layer]+1);
          node["x"] = x;
          node["y"] = y;
          nodes.push(node);
        }
        return nodes;
      }
      
      var nodes = positionNodes(data, networkStructure);
    </script>
  
    <script> // draw lines between nodes
      var lines = [];
      for(var start = 0; start < nodes.length; start++) {
        var startNode = nodes[start];
        for(var end = 0; end < nodes.length; end++) {
          var endNode = nodes[end];
          if(endNode.layer === startNode.layer + 1) {
            // find weight for connection from weights array, if any
            
            lineweight = weights.find(function(x) {return x.startLabel === startNode.label
                                                       && x.endLabel === endNode.label;});
            if(lineweight) {
              lineweight = lineweight.weight;
            }
            else {
              lineweight = 1;
            }
              
            lines.push({"x1": startNode.x, 
                        "y1": startNode.y,
                        "x2": endNode.x, 
                        "y2": endNode.y, 
                        "weight": lineweight,
                        "connection": startNode.layer.toString() + "-" + endNode.layer.toString(),
                        // id format: index_of_startNode_in_nodes-index_of_endNode_in_nodes
                        "id": start.toString() + "-" + end.toString()}); 
          }
        }
      }  
    </script>
    <script type='text/template' id='defs'>

        <link id="knobstyle" href="knob/style.css" type="text/css" rel="stylesheet"></link>
          <radialGradient id="knobgradient"> <!-- referenced in CSS -->
            <stop offset="0" stop-color="gray"/>
            <stop offset="1" stop-color="silver"/>
          </radialGradient>

      </script>
  
      <script type='text/template' id='knob'>
        <g class="knob" data-speed="null" data-rotations="null">
          <circle class="knob_center" cx="0" cy="0" r="0.015625"/>
          <g class="knob_gfx">
            <circle cx="0" cy="0" r="5"/>
            <line x1="0" y1="-2.5" x2="0" y2="-4.5"/>
          </g>
          <text class="knob_number"/>
        </g>
      </script>
  
    <script>
      var svg = d3.select("body").append("svg")
        .attr("xmlns", "http://www.w3.org/2000/svg")
        .attr("width", width)
        .attr("height", height);
//        .attr("onmousedown", "getCoords(event)")
//        .attr("onmousemove", "adjustWeight(event)")
//        .attr("onmouseup", "stopmousedown(event)");
      
      var knobgradient = d3.select('#defs').html();
      var gradient = svg.append(function() {
        var g = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        g.innerHTML = knobgradient;
        return g;
      });
      
      var style = svg.append(function() {
        return document.getElementById('knobstyle');
      });
      
      var line = svg.selectAll("lines")
                    .data(lines).enter()
                    .append("path")
                      .attr("d", function(d) { return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;})
                      .attr("stroke", "black")
                      .attr("stroke-width", function(d) { return Math.abs(d.weight); })
                      .attr("id", function(d) {return d.id;});
      // an invisible line that is thicker than the actual line for ease of interaction
      var selectable = svg.selectAll("selectable")
                    .data(lines).enter()
                    .append("path")
                      .attr("d", function(d) { return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;})
//                      .attr("stroke", "red")
                      .attr("stroke-width", nodeSize)
                      .attr("data-line", function(d) {return d.id;})
                      .attr("pointer-events", "visible");
      
      // known bug: horizontal lines don't thicken when dragged (drag event isn't even triggered)
      var drag = d3.behavior.drag()
          .on("drag", function(d, i) {
            
              var weight = document.getElementById(this.getAttribute('data-line'));
              var weightlabel = document.querySelectorAll('[*|href="#' + this.getAttribute('data-line') + '"]')[0];
              strokewidth = parseInt(document.querySelectorAll('[*|href="#' + this.getAttribute('data-line') + '"]')[0].innerHTML);

              if(d3.event.dy > 0 && strokewidth < nodeSize) {
                strokewidth = strokewidth+1;
                weight.setAttribute('stroke-width', Math.abs(strokewidth));
              }
              else if(d3.event.dy <= 0 && strokewidth > -nodeSize) {
                strokewidth = strokewidth-1;
                weight.setAttribute('stroke-width', Math.abs(strokewidth));
              }
              weightlabel.innerHTML = strokewidth;
            
              // adjust weight text as line thickens
              weightlabel.parentElement.setAttribute("dy", (-Math.abs(strokewidth)/2-12).toString());
          
          }
      );
      selectable.call(drag);
      
      var weightlabels = svg.selectAll("weights")
                    .data(lines).enter()
                    .append("text")
                      .attr("style", "text-anchor: left;")
                      .attr("dy", -12)
      weightlabels.append("textPath")
                      .attr("xlink:href", function(d) {return "#" + d.id})
                      .attr("data-node-to-node-index", function(d) {return d.id})
                      .attr("startOffset", "20%")
                      .text(function(d) {return d.weight;});
      weightlabels.append("textPath")
                      .attr("xlink:href", function(d) {return "#" + d.id})
                      .attr("data-layer-to-layer", function(d) {return d.connection;})
                      .attr("startOffset", "0%")
                      .text();

      var node = svg.selectAll("node")
        .data(nodes)
        .enter()
        .append("g")
//          .attr("class", "dial")
          .attr("transform", function(d) {
            return "translate(" + d.x + ", " + d.y + ")";});
      

      
      
//      var circle = node.append("circle")
//          .attr("r", nodeSize)
//          .attr("class", "node");

      function changeInput() {
        var i = this.getAttribute('data-node');
        d3.selectAll('.nodetext')[0][i].innerHTML = d3.selectAll('.input_slider')[0][i].value;
      }
      
        var knobcode = d3.select('#knob').html();
        var knobs = node.append(function(d, i) {
        // make this if statement, check data if 1 < layer < max and draw sliders for input output layers
        if(d.layer === inputlayer) {
          var g = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          g.setAttribute("r", nodeSize);
          g.setAttribute("class", "node");
          g.setAttribute("fill", inputcolor);
          
          
          // add slider
          svg.append("foreignObject")
              .attr("width", nodeSize)
              .attr("height", nodeSize*4)
              .attr("x", d.x - 2*nodeSize)
              .attr("y", d.y - 2*nodeSize)
              .append("xhtml:form").append("xhtml:input") // xhtml tells d3.js it's HTML, not SVG
                  .attr("class", "input_slider")
                  .attr("value", 0)
                  .attr("min", -100)
                  .attr("max", 100)
                  .attr("type", "range")
                  .attr("style", "height: " + (nodeSize*4-10).toString())
                  .attr("orient", "vertical")
                  .attr("data-node", i)
                  .attr("oninput", "changeInput.apply(this)");
//          var g = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
//          g.setAttribute("width", "25");
//          g.setAttribute("height", "100");
//          
//          // because of browser bugs, translated svg elements cause foreignObject elements
//          // to be offset: 
//          // http://stackoverflow.com/questions/32960248/svg-transformtranslate-breaks-input-range-offset
//          node[0][i].setAttribute("transform", ""); // untransform parent node
//          // transform this individual node instead
//          g.setAttribute("x", d.x);
//          g.setAttribute("y", d.y);
//          g.innerHTML = "<body><form><input style='-webkit-appearance: slider-vertical' type='range' orient='vertical'/></form></body>";
        }
        else if(d.layer === outputlayer) {
          // create dud node that doesn't do anything
          var g = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          g.setAttribute("r", nodeSize);
          g.setAttribute("class", "node");
          g.setAttribute("fill", outputcolor);
          g.setAttribute("data-layers", i);
          // display output
          
        }
        else {
          // create knobs that allow users to adjust bias
          var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.innerHTML = knobcode;
          g.setAttribute("viewBox", "-6 -6 24 24");
          g.setAttribute("style", "transform: scale(5)");
          g.setAttribute('class', 'node dial');
          g.getElementsByClassName('knob_number')[0].setAttribute('data-layers', i);
        }
        return g;
      });

      
      var text = node.append("text")
          .attr("class", "nodetext")
          .attr("style", "text-anchor: middle; alignment-baseline: middle;")
          .attr("dx", 0)
          .attr("dy", 0)
          .attr("fill", "white")
          .attr("data-layers", function(d, i) {return i;})
          .text(function addSlider(d, i) {
            if(d.layer === inputlayer) {
              return d3.selectAll(".input_slider")[0][i].value;
            }
            else {
              return "";
            }
          });
      
      
    </script>
  
  <script>
    var layercount = inputlayer;
    function moveText() {
      // select all weights between layercount and layercount + 1
      var label = d3.selectAll("[data-layer-to-layer='" + layercount.toString() + "-" + (layercount+1).toString() + "']");
      label.attr("startOffset", "0%");
      label.style("opacity", 1);
      label.each(function(d, i) { // figure out where and what text to display 
        // get index of starting node
        var start = parseInt(this.getAttribute('href').slice(1)); 
        
        // get value displayed on starting node
        var value = d3.select("[data-layers='" + start + "']")[0][0].innerHTML;
        
        // input node is special; it simply outputs its value
        if(layercount === inputlayer) {
          var operation = "â€¢ ";
          
          // if value negative, wrap it in parentheses
          if(parseInt(value) < 0) {value = "(" + value + ")";}
        }
        else if(parseInt(value) > 0){
          var operation = "+ ";
        }
        else {
          var operation = "- ";
          value = value.slice(1); // remove negative sign on value
        }
        this.innerHTML = operation + value;
        
        
        /* figure out where text should be moved to 
           so that it aligns with existing text */
        var weightlabelwidth = d3.selectAll("[*|href='" + this.getAttribute('href') + "']")[0][0].getBBox().width;
        var linewidth = document.getElementById(this.getAttribute('href').slice(1)).getBBox().width;
        d.startOffset = weightlabelwidth/linewidth*100;
      });
      label.transition().attr("startOffset", function(d, i) {
        return d.startOffset.toString() + "%";
      }).duration(1000).delay(100);
//      var pos = 0;
//      var interval = setInterval(move, 10);
//      function move() {
//        if(pos === 30) {
//          clearInterval(interval);
//        }
//        else {
//          pos++;
//          label.attr("startOffset", pos.toString() + "%");
//          label.each(function(p, j) {
//              var start = parseInt(this.getAttribute('href').slice(1)); // idk wtf I'm doing
//              var value = d3.select("[data-layers='" + start + "']")[0][0].innerHTML;
//              var sign = "+ ";
//              if(parseInt(value) < 0) {sign = "- "; value = value.slice(1);}
//              this.innerHTML = sign + value;
//            })
//          
//        }
        if(layercount < outputlayer) {
          layercount++;
        }
      }
      
    
    // bug that I'm too lazy to fix: clicking 'next' right after 'reset' button
    // results in half-formed transitions
    function resetSim() {
      layercount = inputlayer;
      var label = d3.selectAll("[data-layer-to-layer]");
      label.transition().style("opacity", 0).duration(500).delay(100);
      
    }
  </script>
  

  <button onclick="moveText.apply(this)">next</button>
  <button onclick="resetSim.apply(this)">reset</button>
</body>
</html>
